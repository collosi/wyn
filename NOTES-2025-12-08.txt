Compute Shader Compilation - Current Status
===========================================

Working on getting testfiles/wall_anneal.wyn (a simulated annealing compute shader) to compile.

Completed fixes:
1. Added #[storage(binding=N)] attribute parsing to parser.rs
2. Added parse_storage_decl() for storage buffer declarations without initializers
3. Added qualified type name parsing (rand.state -> TypeName::Named("rand.state"))
4. Fixed uppercase variable names (H -> h, T -> temp) that were being parsed as constructors
5. Fixed module registration - modules loaded from prelude now added to known_modules set

Current problem:
================
Type mismatch between `rand.state` and `state`:

  Error: Function argument type mismatch:
    Failure(Constructed(Named("rand.state"), []), Constructed(Named("state"), []))

The rand module defines:
  module rand = {
    type state = f32
    def init (seed: f32): state = ...
    def int (s: state) (n: i32): (state, i32) = ...
    ...
  }

When user code has:
  def anneal_step (rng: rand.state) ... =
    let (rng2, idx) = rand.int rng NUM_BRICKS in ...

The parameter `rng` has type `rand.state` (parsed as TypeName::Named("rand.state")),
but `rand.int` expects `state` (TypeName::Named("state")).

These should be the same type, but the type system doesn't know that `rand.state`
refers to the `state` type alias defined inside the `rand` module.

Possible solutions:
1. Add TypeAlias variant to ElaboratedItem, track type aliases from module bodies
2. When resolving a qualified type name like `rand.state`, look up the module's
   type aliases and expand to the underlying type
3. Store type aliases in a separate registry (module_name.type_name -> Type)

The module_manager currently skips Declaration::TypeBind in elaborate_module_body()
(line 666: `_ => { // Skip other declaration types }`), so type aliases like
`type state = f32` are not being recorded anywhere.
