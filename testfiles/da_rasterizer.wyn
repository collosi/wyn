-- Original GLSL source code
--
-- #define LINEAR_ROTATION
-- 
-- #define WEIGHT (3.0 / iResolution.x)
-- const vec3 RED = vec3(1.0,0.0,0.0);
-- const vec3 GREEN = vec3(0.0,1.0,0.0);
-- const vec3 BLUE = vec3(0.0,0.8,1.0);
-- const vec3 WHITE = vec3(1.0,1.0,0.97);
-- const vec3 YELLOW = vec3(1.0,1.0,0.0);
-- 
-- // rasterize functions
-- float line(vec2 p, vec2 p0, vec2 p1, float w) {
--     vec2 d = p1 - p0;
--     float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);
--     vec2 proj = p0 + d * t;
--     float dist = length(p - proj);
--     dist = 1.0/dist*WEIGHT*w;
--     return min(dist*dist,1.0);
-- }
-- float circle(vec2 p, vec2 c, float r, float w) {
--     float dist = abs(length(p - c)) + r;
--     dist = 1.0/dist*WEIGHT*w;
--     return min(dist*dist,1.0);
-- }
-- 
-- // matrices
-- mat4 getRotMatrix(vec3 a) {
--     vec3 s = sin(a);
--     vec3 c = cos(a);    
--     mat4 ret;
--     ret[0] = vec4(c.y*c.z,c.y*s.z,-s.y,0.0);
--     ret[1] = vec4(s.x*s.y*c.z-c.x*s.z,s.x*s.y*s.z+c.x*c.z,s.x*c.y,0.0);
--     ret[2] = vec4(c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z,   c.x*c.y,0.0);    
--     ret[3] = vec4(0.0,0.0,0.0,1.0);
--     return ret;
-- }
-- mat4 getPosMatrix(vec3 p) {   
--     mat4 ret;
--     ret[0] = vec4(1.0,0.0,0.0,p.x);
--     ret[1] = vec4(0.0,1.0,0.0,p.y);
--     ret[2] = vec4(0.0,0.0,1.0,p.z);   
--     ret[3] = vec4(0.0,0.0,0.0,1.0);
--     return ret;
-- }
-- 
-- // utils
-- vec3 mix3(vec3 a, vec3 b, vec3 c, float t) {
--     if(t>0.5) return mix(b,c,t*2.0-1.0);
--     else return mix(a,b,t*2.0);
-- }
-- vec3 fragment(vec3 p) {
--     float t = sin(p.x*0.8+iTime*0.5)*0.5+0.5;
--     float fog = min(pow(p.z,3.0)*400.0,1.0);
--     return mix3(RED,GREEN,BLUE,t) * fog;
-- }    
-- 
-- void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
-- 	vec2 uv = fragCoord.xy / iResolution.xy;
--     uv = uv * 2.0 - 1.0;
--     uv.x *= iResolution.x / iResolution.y;
--     //uv = uv * (1.0 + pow(length(uv)*0.4,0.5)) * 0.6;
--     
--     float line_width = 0.4;
--     float time = iTime * 0.31415;
--     vec3 c = vec3(mix(vec3(0.19,0.13,0.1),vec3(1.0), 0.5*pow(length(uv)*0.5,2.0)));
--     mat4 cam = getPosMatrix(vec3(0.0,0.0,10.0));
--     
-- #ifdef LINEAR_ROTATION
--     mat4 rot = getRotMatrix(vec3(time,time*0.86,time*0.473));
-- #else
--     float p = 0.08;
--     mat4 rot = getRotMatrix(vec3(time		+sin(time*30.0)*p,
--                                  time*0.860	+sin(time*20.0)*p*1.24,
--                                  time*0.473	+sin(time*10.0)*p));
-- #endif
--     
--     vec3 instances[18];
--     instances[0] = vec3( 0.0, 0.0,-1.0);
--     instances[1] = vec3(-1.0, 0.0,-1.0);
--     instances[2] = vec3( 1.0, 0.0,-1.0);
--     instances[3] = vec3( 0.0, 1.0,-1.0);
--     instances[4] = vec3( 0.0,-1.0,-1.0);    
--     instances[5] = vec3(-1.0, 0.0, 0.0);
--     instances[6] = vec3( 1.0, 0.0, 0.0);
--     instances[7] = vec3( 0.0, 1.0, 0.0);
--     instances[8] = vec3( 0.0,-1.0, 0.0);        
--     instances[9] = vec3(-1.0,-1.0, 0.0);
--     instances[10] = vec3( 1.0, 1.0, 0.0);
--     instances[11] = vec3(-1.0, 1.0, 0.0);
--     instances[12] = vec3( 1.0,-1.0, 0.0);    
--     instances[13] = vec3( 0.0, 0.0, 1.0);
--     instances[14] = vec3(-1.0, 0.0, 1.0);
--     instances[15] = vec3( 1.0, 0.0, 1.0);
--     instances[16] = vec3( 0.0, 1.0, 1.0);
--     instances[17] = vec3( 0.0,-1.0, 1.0);
--     
--     // box pipeline
--     for(int dip = 0; dip < 18; dip++) {
--         
--         // input assembly
--         vec3 vert[8];
--         vert[0] = vec3(-1.0,-1.0, 1.0);
--         vert[1] = vec3(-1.0, 1.0, 1.0);    
--         vert[2] = vec3( 1.0, 1.0, 1.0);    
--         vert[3] = vec3( 1.0,-1.0, 1.0);
--         vert[4] = vec3(-1.0,-1.0,-1.0);
--         vert[5] = vec3(-1.0, 1.0,-1.0);    
--         vert[6] = vec3( 1.0, 1.0,-1.0);    
--         vert[7] = vec3( 1.0,-1.0,-1.0);
-- 
--         // vertex processing        
--         mat4 pos = getPosMatrix(instances[dip] * 4.0);
--         mat4 mat = pos * rot * cam;
-- 
--         for(int i = 0; i < 8; i++) {
-- 
--             // transform
--             vert[i] = (vec4(vert[i],1.0) * mat).xyz;
-- 
--             // perspective
--             vert[i].z = 1.0 / vert[i].z;
--             vert[i].xy *= vert[i].z;
--         }    
-- 
--         // primitive assembly and rasterize
--         float i;
--         i  = line(uv,vert[0].xy,vert[1].xy,line_width);
--         i += line(uv,vert[1].xy,vert[2].xy,line_width);
--         i += line(uv,vert[2].xy,vert[3].xy,line_width);
--         i += line(uv,vert[3].xy,vert[0].xy,line_width);
--         i += line(uv,vert[4].xy,vert[5].xy,line_width);
--         i += line(uv,vert[5].xy,vert[6].xy,line_width);
--         i += line(uv,vert[6].xy,vert[7].xy,line_width);
--         i += line(uv,vert[7].xy,vert[4].xy,line_width);
--         i += line(uv,vert[0].xy,vert[4].xy,line_width);
--         i += line(uv,vert[1].xy,vert[5].xy,line_width);
--         i += line(uv,vert[2].xy,vert[6].xy,line_width);
--         i += line(uv,vert[3].xy,vert[7].xy,line_width);
--         c += fragment(vert[0]) * min(i,1.0);
--     }
--         
--     instances[0] = vec3(-1.0, 1.0,-1.0);
--     instances[1] = vec3( 1.0, 1.0,-1.0);
--     instances[2] = vec3(-1.0,-1.0,-1.0);
--     instances[3] = vec3( 1.0,-1.0,-1.0);
--     instances[4] = vec3(-1.0, 1.0, 1.0);
--     instances[5] = vec3( 1.0, 1.0, 1.0);
--     instances[6] = vec3(-1.0,-1.0, 1.0);
--     instances[7] = vec3( 1.0,-1.0, 1.0);
--     
--     // cicle pipeline
--     for(int dip = 0; dip < 8; dip++) {
--         
--         // input assembly
--         vec3 vert = vec3(0.0);
-- 
--         // vertex processing
--         mat4 pos = getPosMatrix(instances[dip] * 4.0);
--         mat4 mat = pos * rot * cam;
-- 
--         // transform
--         vert = (vec4(vert,1.0) * mat).xyz;
-- 
--         // perspective
--         vert.z = 1.0 / vert.z;
--         vert.xy *= vert.z;
-- 
--         // rasterize
--         c += fragment(vert) * circle(uv,vert.xy,-vert.z,line_width);
--     }
--     
--     // fragment
-- 	fragColor = vec4(c,1.0);
-- }



-- Vertex shader: full-screen triangle
def verts: [3]vec4f32 =
  [vec4 -1.0f32 -1.0f32 0.0f32 1.0f32,
   vec4 3.0f32 -1.0f32 0.0f32 1.0f32,
   vec4 -1.0f32 3.0f32 0.0f32 1.0f32]

#[vertex]
def vertex_main (#[builtin(vertex_index)] vertex_id:i32) : #[builtin(position)] vec4f32 = verts[vertex_id]

-- Constants (changed to def for top-level, using vec3 constructors)
def red : vec3f32 = vec3 1.0f32 0.0f32 0.0f32
def green : vec3f32 = vec3 0.0f32 1.0f32 0.0f32
def blue : vec3f32 = vec3 0.0f32 0.8f32 1.0f32
def white : vec3f32 = vec3 1.0f32 1.0f32 0.97f32
def yellow : vec3f32 = vec3 1.0f32 1.0f32 0.0f32

-- Helper functions
def clamp (x:f32) (min:f32) (max:f32) : f32 =
  if x < min then min else if x > max then max else x

def mix3v (a:vec3f32) (b:vec3f32) (t:f32) : vec3f32 =
  vec3 (a.x + (b.x - a.x) * t) (a.y + (b.y - a.y) * t) (a.z + (b.z - a.z) * t)

-- Vector magnitude (Euclidean length)
def length2 (v:vec2f32) : f32 =
  f32.sqrt (v.x * v.x + v.y * v.y)

def length3 (v:vec3f32) : f32 =
  f32.sqrt (v.x * v.x + v.y * v.y + v.z * v.z)

-- Rasterize helpers
def line (weight:f32) (p:vec2f32) (p0:vec2f32) (p1:vec2f32) (w:f32) : f32 =
  let d = vec2 (p1.x-p0.x) (p1.y-p0.y) in
  let denom = dot d d in
  let dp = vec2 (p.x-p0.x) (p.y-p0.y) in
  let t_raw = if denom == 0.0f32 then 0.0f32 else (dot d dp / denom) in
  let t = clamp t_raw 0.0f32 1.0f32 in
  let proj = vec2 (p0.x + d.x*t) (p0.y + d.y*t) in
  let pdiff = vec2 (p.x-proj.x) (p.y-proj.y) in
  let dist = length2 pdiff in
  let s = (if dist == 0.0f32 then 0.0f32 else (1.0f32 / dist)) * weight * w in
  f32.min (s*s) 1.0f32

def circle (weight:f32) (p:vec2f32) (c:vec2f32) (r:f32) (w:f32) : f32 =
  let diff = vec2 (p.x-c.x) (p.y-c.y) in
  let dist = f32.abs (length2 diff) + r in
  let s = (if dist == 0.0f32 then 0.0f32 else (1.0f32 / dist)) * weight * w in
  f32.min (s*s) 1.0f32

-- Matrices
def getRotMatrix (a:vec3f32) : mat4f32 =
  let s = [ f32.sin a.x, f32.sin a.y, f32.sin a.z ] in
  let c = [ f32.cos a.x, f32.cos a.y, f32.cos a.z ] in
  -- Columns ret[0..3], matching GLSL code:
  let c0 : vec4f32 = vec4 (c[1]*c[2]) (c[1]*s[2]) (-s[1]) 0.0f32 in
  let c1 : vec4f32 = vec4 (s[0]*s[1]*c[2]-c[0]*s[2]) (s[0]*s[1]*s[2]+c[0]*c[2]) (s[0]*c[1]) 0.0f32 in
  let c2 : vec4f32 = vec4 (c[0]*s[1]*c[2]+s[0]*s[2]) (c[0]*s[1]*s[2]-s[0]*c[2]) (c[0]*c[1]) 0.0f32 in
  let c3 : vec4f32 = vec4 0.0f32 0.0f32 0.0f32 1.0f32 in
  matav [c0,c1,c2,c3]

def getPosMatrix (p:vec3f32) : mat4f32 =
  let c0 : vec4f32 = vec4 1.0f32 0.0f32 0.0f32 p.x in
  let c1 : vec4f32 = vec4 0.0f32 1.0f32 0.0f32 p.y in
  let c2 : vec4f32 = vec4 0.0f32 0.0f32 1.0f32 p.z in
  let c3 : vec4f32 = vec4 0.0f32 0.0f32 0.0f32 1.0f32 in
  matav [c0,c1,c2,c3]

-- utils
def mix3 (a:vec3f32) (b:vec3f32) (c:vec3f32) (t:f32) : vec3f32 =
  if t > 0.5f32
  then mix3v b c (t*2.0f32 - 1.0f32)
  else mix3v a b (t*2.0f32)

def fragment (p:vec3f32) (iTime:f32) : vec3f32 =
  let t = f32.sin(p.x*0.8f32 + iTime*0.5f32)*0.5f32 + 0.5f32 in
  let fog = f32.min (p.z*p.z*p.z*400.0f32) 1.0f32 in
  let col = mix3 red green blue t in
  vec3 (col.x * fog) (col.y * fog) (col.z * fog)

-- Main per-fragment function
-- Inputs:
--   iResolution : [w, h]
--   iTime       : time in seconds
--   fragCoord   : pixel coordinate [x, y]
-- Output: vec4f32 color
def main_image (iResolution:[2]f32) (iTime:f32) (fragCoord:vec2f32) : vec4f32 =
  let weight = 3.0f32 / iResolution[0] in

  -- Normalized, centered UV with aspect correction
  let uv0 : vec2f32 = vec2 (fragCoord.x / iResolution[0]) (fragCoord.y / iResolution[1]) in
  let uv1 : vec2f32 = vec2 (uv0.x*2.0f32 - 1.0f32) (uv0.y*2.0f32 - 1.0f32) in
  let uv  : vec2f32 = vec2 (uv1.x * (iResolution[0]/iResolution[1])) uv1.y in

  let line_width = 0.4f32 in
  let time = iTime * 0.31415f32 in

  let base_col = mix3v (vec3 0.19f32 0.13f32 0.10f32) (vec3 1.0f32 1.0f32 1.0f32)
                         (0.5f32 * f32.pow (length2 uv * 0.5f32) 2.0f32) in
  let cam = getPosMatrix (vec3 0.0f32 0.0f32 10.0f32) in

  -- #define LINEAR_ROTATION
  let rot = getRotMatrix (vec3 time (time*0.86f32) (time*0.473f32)) in

  -- Instances (first batch, 18 boxes)
  let instA : [18]vec3f32 =
    [ vec3 0.0f32 0.0f32 (-1.0f32),
      vec3 (-1.0f32) 0.0f32 (-1.0f32),
      vec3 1.0f32 0.0f32 (-1.0f32),
      vec3 0.0f32 1.0f32 (-1.0f32),
      vec3 0.0f32 (-1.0f32) (-1.0f32),
      vec3 (-1.0f32) 0.0f32 0.0f32,
      vec3 1.0f32 0.0f32 0.0f32,
      vec3 0.0f32 1.0f32 0.0f32,
      vec3 0.0f32 (-1.0f32) 0.0f32,
      vec3 (-1.0f32) (-1.0f32) 0.0f32,
      vec3 1.0f32 1.0f32 0.0f32,
      vec3 (-1.0f32) 1.0f32 0.0f32,
      vec3 1.0f32 (-1.0f32) 0.0f32,
      vec3 0.0f32 0.0f32 1.0f32,
      vec3 (-1.0f32) 0.0f32 1.0f32,
      vec3 1.0f32 0.0f32 1.0f32,
      vec3 0.0f32 1.0f32 1.0f32,
      vec3 0.0f32 (-1.0f32) 1.0f32 ] in

  -- Accumulate color
  let c_box_result =
    loop (idx, acc) = (0i32, base_col) while idx < 18 do
      let inst = instA[idx] in
      let pos  = getPosMatrix (vec3 (inst.x * 4.0f32) (inst.y * 4.0f32) (inst.z * 4.0f32)) in
      let mat  : mat4f32 = mul (mul pos rot) cam in

      -- 8 cube corners in object space
      let verts0 : [8]vec3f32 =
        [ vec3 (-1.0f32) (-1.0f32) 1.0f32,
          vec3 (-1.0f32) 1.0f32 1.0f32,
          vec3 1.0f32 1.0f32 1.0f32,
          vec3 1.0f32 (-1.0f32) 1.0f32,
          vec3 (-1.0f32) (-1.0f32) (-1.0f32),
          vec3 (-1.0f32) 1.0f32 (-1.0f32),
          vec3 1.0f32 1.0f32 (-1.0f32),
          vec3 1.0f32 (-1.0f32) (-1.0f32) ] in

      -- Transform & perspective
      let v4s : [8]vec4f32 = map (\(v:vec3f32) -> mul mat (vec4 v.x v.y v.z 1.0f32)) verts0 in
      let verts1 : [8]vec3f32 =
        map (\(q:vec4f32) ->
                  let zinv = 1.0f32 / q.z in
                  vec3 (q.x*zinv) (q.y*zinv) zinv)
               v4s in

      -- Rasterize edges
      let edges : [12][2]i32 =
        [ [0,1],[1,2],[2,3],[3,0],
          [4,5],[5,6],[6,7],[7,4],
          [0,4],[1,5],[2,6],[3,7] ] in

      let i_sum =
        f32.sum (map (\e ->
          let a = verts1[e[0]] in
          let b = verts1[e[1]] in
          line weight uv (vec2 a.x a.y) (vec2 b.x b.y) line_width)
          edges) in

      let shade = fragment verts1[0] iTime in
      let intensity = f32.min i_sum 1.0f32 in
      let shade_scaled = vec3 (shade.x * intensity) (shade.y * intensity) (shade.z * intensity) in
      let acc' = vec3 (acc.x + shade_scaled.x) (acc.y + shade_scaled.y) (acc.z + shade_scaled.z) in
      (idx + 1, acc') in
  let (dummy1, c_box) = c_box_result in

  -- Second instances (8 circles)
  let instB : [8]vec3f32 =
    [ vec3 (-1.0f32) 1.0f32 (-1.0f32),
      vec3 1.0f32 1.0f32 (-1.0f32),
      vec3 (-1.0f32) (-1.0f32) (-1.0f32),
      vec3 1.0f32 (-1.0f32) (-1.0f32),
      vec3 (-1.0f32) 1.0f32 1.0f32,
      vec3 1.0f32 1.0f32 1.0f32,
      vec3 (-1.0f32) (-1.0f32) 1.0f32,
      vec3 1.0f32 (-1.0f32) 1.0f32 ] in

  let c_final_result =
    loop (idx, acc) = (0i32, c_box) while idx < 8 do
      let inst = instB[idx] in
      let pos = getPosMatrix (vec3 (inst.x * 4.0f32) (inst.y * 4.0f32) (inst.z * 4.0f32)) in
      let mat : mat4f32 = mul (mul pos rot) cam in
      let v4  : vec4f32 = mul mat (vec4 0.0f32 0.0f32 0.0f32 1.0f32) in
      let zinv = 1.0f32 / v4.z in
      let vert : vec3f32 = vec3 (v4.x*zinv) (v4.y*zinv) zinv in
      let sh  = fragment vert iTime in
      let cov = circle weight uv (vec2 vert.x vert.y) (-vert.z) line_width in
      let sh_scaled = vec3 (sh.x * cov) (sh.y * cov) (sh.z * cov) in
      let acc' = vec3 (acc.x + sh_scaled.x) (acc.y + sh_scaled.y) (acc.z + sh_scaled.z) in
      (idx + 1, acc') in
  let (dummy2, c_final) = c_final_result in

  vec4 c_final.x c_final.y c_final.z 1.0f32

-- Fragment shader entry point
#[fragment]
def fragment_main (#[builtin(frag_coord)] pos:vec4f32) : #[location(0)] vec4f32 =
  let width = 800.0f32 in
  let height = 600.0f32 in
  let time = 1.0f32 in
  -- Debug output for center pixel only
  let is_center = if pos.x > 399.0f32 then
      if pos.x < 401.0f32 then
        if pos.y > 299.0f32 then
          if pos.y < 301.0f32 then true else false
        else false
      else false
    else false in
  let _ = if is_center then
      let _ = debug_str "frag:" in
      let _ = debug_f32 pos.x in
      let _ = debug_f32 pos.y in
      ()
    else
      () in
  let result = main_image [width, height] time (vec2 pos.x pos.y) in
  -- Debug the final color for center pixel
  let _ = if is_center then
      let _ = debug_str "col:" in
      let _ = debug_f32 result.x in
      let _ = debug_f32 result.y in
      let _ = debug_f32 result.z in
      ()
    else
      () in
  result
