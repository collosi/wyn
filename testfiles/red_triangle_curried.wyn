-- Red triangle demonstrating partial application (currying)

def vec4 (x: f32) (y: f32) (z: f32) (w: f32): vec4f32 = @[x, y, z, w]
def vec3 (x: f32) (y: f32) (z: f32): vec3f32 = @[x, y, z]

def select_position (idx: i32): vec4f32 =
  -- Partial application: vec4 0.0f32 returns f32 -> f32 -> f32 -> vec4f32
  -- Then applying 0.5f32 returns f32 -> f32 -> vec4f32, etc.
  let at_z_w = vec4 0.0f32 0.5f32 in  -- f32 -> f32 -> vec4f32
  let at_origin = at_z_w 0.0f32 1.0f32 in
  if idx == 0 then vec4 (-0.5f32) (-0.5f32) 0.0f32 1.0f32
  else if idx == 1 then vec4 0.5f32 (-0.5f32) 0.0f32 1.0f32
  else at_origin

#[vertex] def vertex_main(#[builtin(vertex_index)] vertex_index: i32): (#[builtin(position)] vec4f32, #[location(0)] vec3f32) =
  let position = select_position vertex_index in
  -- Partial application: vec3 1.0f32 returns f32 -> f32 -> vec3f32
  let make_red = vec3 1.0f32 in
  let color = make_red 0.0f32 0.0f32 in
  (position, color)

#[fragment] def fragment_main(#[location(0)] color: vec3f32): #[location(0)] vec4f32 =
  vec4 color.x color.y color.z 1.0f32