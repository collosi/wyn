use crate::NodeId;
use std::io::Write;

/// Generates Nemo/Datalog facts for borrow checking analysis
///
/// Facts are based on NodeId from AST headers, representing locations in the source.
pub struct NemoFactWriter<W: Write> {
    writer: W,
    debug: bool,
}

impl<W: Write> NemoFactWriter<W> {
    pub fn new(writer: W, debug: bool) -> Self {
        Self { writer, debug }
    }

    /// Write a comment header for the facts file
    pub fn write_header(&mut self) -> Result<(), std::io::Error> {
        writeln!(self.writer, "% Nemo/Datalog facts for Wyn borrow checking")?;
        writeln!(self.writer, "% Generated by Wyn compiler")?;
        writeln!(self.writer)?;
        writeln!(self.writer, "% Base predicates (facts):")?;
        writeln!(
            self.writer,
            "%   var_def(NodeId, VarName) - variable defined at node"
        )?;
        writeln!(
            self.writer,
            "%   var_use(NodeId, VarName) - variable used at node"
        )?;
        writeln!(
            self.writer,
            "%   parent(ParentId, ChildId) - AST parent-child edge"
        )?;
        writeln!(
            self.writer,
            "%   scope_intro(NodeId, VarName) - node introduces scope for variable"
        )?;
        writeln!(
            self.writer,
            "%   move_point(NodeId, VarName) - variable is moved at node"
        )?;
        writeln!(self.writer)?;
        Ok(())
    }

    /// Write variable definition fact: var_def(NodeId, VarName).
    pub fn write_var_def(&mut self, node_id: NodeId, var_name: &str) -> Result<(), std::io::Error> {
        writeln!(self.writer, "var_def({}, \"{}\").", node_id.0, var_name)?;
        if self.debug {
            eprintln!("DEBUG: var_def({}, \"{}\")", node_id.0, var_name);
        }
        Ok(())
    }

    /// Write variable use fact: var_use(NodeId, VarName).
    pub fn write_var_use(&mut self, node_id: NodeId, var_name: &str) -> Result<(), std::io::Error> {
        writeln!(self.writer, "var_use({}, \"{}\").", node_id.0, var_name)?;
        if self.debug {
            eprintln!("DEBUG: var_use({}, \"{}\")", node_id.0, var_name);
        }
        Ok(())
    }

    /// Write parent-child relationship: parent(ParentId, ChildId).
    pub fn write_parent(&mut self, parent_id: NodeId, child_id: NodeId) -> Result<(), std::io::Error> {
        writeln!(self.writer, "parent({}, {}).", parent_id.0, child_id.0)?;
        if self.debug {
            eprintln!("DEBUG: parent({}, {})", parent_id.0, child_id.0);
        }
        Ok(())
    }

    /// Write scope introduction: scope_intro(NodeId, VarName).
    /// This marks where a variable's scope begins (let binding, lambda param, fn param).
    pub fn write_scope_intro(&mut self, node_id: NodeId, var_name: &str) -> Result<(), std::io::Error> {
        writeln!(self.writer, "scope_intro({}, \"{}\").", node_id.0, var_name)?;
        if self.debug {
            eprintln!("DEBUG: scope_intro({}, \"{}\")", node_id.0, var_name);
        }
        Ok(())
    }

    /// Write move point: move_point(NodeId, VarName).
    /// This marks where a variable is consumed/moved.
    pub fn write_move_point(&mut self, node_id: NodeId, var_name: &str) -> Result<(), std::io::Error> {
        writeln!(self.writer, "move_point({}, \"{}\").", node_id.0, var_name)?;
        if self.debug {
            eprintln!("DEBUG: move_point({}, \"{}\")", node_id.0, var_name);
        }
        Ok(())
    }

    /// Write the Nemo rules for borrow checking analysis
    pub fn write_rules(&mut self) -> Result<(), std::io::Error> {
        writeln!(self.writer)?;
        writeln!(self.writer, "% Derived rules:")?;
        writeln!(self.writer)?;

        // Ancestor relationship (transitive closure of parent)
        writeln!(self.writer, "% Transitive ancestor relationship")?;
        writeln!(self.writer, "ancestor(?a, ?d) :- parent(?a, ?d).")?;
        writeln!(
            self.writer,
            "ancestor(?a, ?d) :- parent(?a, ?c), ancestor(?c, ?d)."
        )?;
        writeln!(self.writer)?;

        // Variable is in scope at a use site
        writeln!(
            self.writer,
            "% Variable in scope: use is a descendant of scope introduction"
        )?;
        writeln!(
            self.writer,
            "in_scope(?use_node, ?var) :- var_use(?use_node, ?var), scope_intro(?scope_node, ?var), ancestor(?scope_node, ?use_node)."
        )?;
        writeln!(self.writer)?;

        // Use after move detection
        writeln!(self.writer, "% Use after move: variable used after being moved")?;
        writeln!(
            self.writer,
            "% A use is invalid if there's a move between the scope intro and the use"
        )?;
        writeln!(
            self.writer,
            "use_after_move(?use_node, ?var) :- var_use(?use_node, ?var), move_point(?move_node, ?var), ancestor(?move_node, ?use_node)."
        )?;
        writeln!(self.writer)?;

        // Output declarations
        writeln!(self.writer, "% Output predicates")?;
        writeln!(self.writer, "@output use_after_move.")?;
        writeln!(self.writer)?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fact_generation() {
        let mut output = Vec::new();
        let mut writer = NemoFactWriter::new(&mut output, false);

        writer.write_header().unwrap();
        writer.write_var_def(NodeId(1), "x").unwrap();
        writer.write_var_use(NodeId(5), "x").unwrap();
        writer.write_parent(NodeId(1), NodeId(5)).unwrap();
        writer.write_scope_intro(NodeId(1), "x").unwrap();
        writer.write_rules().unwrap();

        let result = String::from_utf8(output).unwrap();
        assert!(result.contains("var_def(1, \"x\")."));
        assert!(result.contains("var_use(5, \"x\")."));
        assert!(result.contains("parent(1, 5)."));
        assert!(result.contains("scope_intro(1, \"x\")."));
        assert!(result.contains("ancestor(?a, ?d) :- parent(?a, ?d)."));
    }
}
