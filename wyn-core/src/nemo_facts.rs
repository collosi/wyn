use std::io::Write;
use crate::ast::*;
use crate::cfg::{BlockId, Location};

/// Generates Nemo/Datalog facts for basic block analysis
pub struct NemoFactWriter<W: Write> {
    writer: W,
    debug: bool,
}

impl<W: Write> NemoFactWriter<W> {
    pub fn new(writer: W, debug: bool) -> Self {
        Self { writer, debug }
    }

    /// Write a basic block fact: block(BlockId).
    pub fn write_block_fact(&mut self, block_id: BlockId) -> Result<(), std::io::Error> {
        writeln!(self.writer, "block({}).", block_id.0)?;
        if self.debug {
            eprintln!("DEBUG: Added block fact: block({})", block_id.0);
        }
        Ok(())
    }

    /// Write a location fact: location(LocationId, BlockId, Index).
    pub fn write_location_fact(&mut self, location_id: usize, location: &Location) -> Result<(), std::io::Error> {
        writeln!(self.writer, "location({}, {}, {}).", 
                location_id, location.block.0, location.index)?;
        if self.debug {
            eprintln!("DEBUG: Added location fact: location({}, {}, {})", 
                     location_id, location.block.0, location.index);
        }
        Ok(())
    }

    /// Write a control flow edge fact: edge(FromBlock, ToBlock).
    pub fn write_edge_fact(&mut self, from_block: BlockId, to_block: BlockId) -> Result<(), std::io::Error> {
        writeln!(self.writer, "edge({}, {}).", from_block.0, to_block.0)?;
        if self.debug {
            eprintln!("DEBUG: Added edge fact: edge({}, {})", from_block.0, to_block.0);
        }
        Ok(())
    }

    /// Write an expression fact: expr_at(LocationId, ExprType).
    pub fn write_expr_fact(&mut self, location_id: usize, expr_type: &str) -> Result<(), std::io::Error> {
        writeln!(self.writer, "expr_at({}, \"{}\").", location_id, expr_type)?;
        if self.debug {
            eprintln!("DEBUG: Added expr fact: expr_at({}, \"{}\")", location_id, expr_type);
        }
        Ok(())
    }

    /// Write variable reference fact: var_ref(LocationId, VarName).
    pub fn write_var_ref_fact(&mut self, location_id: usize, var_name: &str) -> Result<(), std::io::Error> {
        writeln!(self.writer, "var_ref({}, \"{}\").", location_id, var_name)?;
        if self.debug {
            eprintln!("DEBUG: Added var_ref fact: var_ref({}, \"{}\")", location_id, var_name);
        }
        Ok(())
    }

    /// Write variable definition fact: var_def(LocationId, VarName).
    pub fn write_var_def_fact(&mut self, location_id: usize, var_name: &str) -> Result<(), std::io::Error> {
        writeln!(self.writer, "var_def({}, \"{}\").", location_id, var_name)?;
        if self.debug {
            eprintln!("DEBUG: Added var_def fact: var_def({}, \"{}\")", location_id, var_name);
        }
        Ok(())
    }

    /// Write a comment header for the facts file
    pub fn write_header(&mut self) -> Result<(), std::io::Error> {
        writeln!(self.writer, "% Nemo/Datalog facts for Wyn basic block analysis")?;
        writeln!(self.writer, "% Generated by Wyn compiler")?;
        writeln!(self.writer, "")?;
        writeln!(self.writer, "% Facts:")?;
        writeln!(self.writer, "% block(BlockId) - A basic block exists")?;
        writeln!(self.writer, "% location(LocationId, BlockId, Index) - A location within a block")?;
        writeln!(self.writer, "% edge(FromBlock, ToBlock) - Control flow edge between blocks")?;
        writeln!(self.writer, "% expr_at(LocationId, ExprType) - Expression type at location")?;
        writeln!(self.writer, "% var_ref(LocationId, VarName) - Variable reference at location")?;
        writeln!(self.writer, "% var_def(LocationId, VarName) - Variable definition at location")?;
        writeln!(self.writer, "")?;
        Ok(())
    }
}

/// Extract expression type name for fact generation
pub fn expr_type_name(expr: &Expression) -> &'static str {
    match expr {
        Expression::IntLiteral(_) => "int_literal",
        Expression::FloatLiteral(_) => "float_literal", 
        Expression::Identifier(_) => "identifier",
        Expression::ArrayLiteral(_) => "array_literal",
        Expression::ArrayIndex(..) => "array_index",
        Expression::BinaryOp(..) => "binary_op",
        Expression::FunctionCall(..) => "function_call",
        Expression::Application(..) => "application",
        Expression::Tuple(_) => "tuple",
        Expression::Lambda(_) => "lambda",
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cfg::BlockId;

    #[test]
    fn test_fact_generation() {
        let mut output = Vec::new();
        let mut writer = NemoFactWriter::new(&mut output, false);
        
        writer.write_header().unwrap();
        writer.write_block_fact(BlockId(0)).unwrap();
        writer.write_block_fact(BlockId(1)).unwrap();
        writer.write_edge_fact(BlockId(0), BlockId(1)).unwrap();
        
        let location = Location { block: BlockId(0), index: 0 };
        writer.write_location_fact(1, &location).unwrap();
        writer.write_expr_fact(1, "binary_op").unwrap();
        writer.write_var_ref_fact(1, "x").unwrap();
        
        let result = String::from_utf8(output).unwrap();
        assert!(result.contains("block(0)."));
        assert!(result.contains("block(1)."));
        assert!(result.contains("edge(0, 1)."));
        assert!(result.contains("location(1, 0, 0)."));
        assert!(result.contains("expr_at(1, \"binary_op\")."));
        assert!(result.contains("var_ref(1, \"x\")."));
    }
}