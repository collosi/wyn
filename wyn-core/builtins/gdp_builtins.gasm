; GDP (GPU Debug Protocol) Builtin Functions
; These functions implement the core GDP encoding operations for GPU debugging

; Global variables for GDP ring buffer
; The ring buffer has the following structure:
; - Word 0: write_head (unbounded atomic counter)
; - Word 1: read_head (for future use)
; - Word 2: max_loops (configured limit to prevent infinite wraparound)
; - Words 3-4095: data buffer (4093 u32 words)
global @gdp_buffer : ptr[global]<u32>

; Constants for ring buffer
; RING_BUFFER_DATA_SIZE = 4093
; RING_BUFFER_HEADER_SIZE = 3

; ============================================================================
; gdp_encode_float32: Encode a f32 value into the GDP ring buffer
;
; This function:
; 1. Bitcasts f32 to u32
; 2. Byte-reverses the bits (for gob encoding efficiency)
; 3. Determines the number of significant bytes
; 4. Writes the GDP type tag (0x03) followed by gob-encoded uint
; 5. Handles ring buffer wraparound for multi-word writes
;
; Arguments:
;   %f: f32 - The float value to encode
;
; GDP Float32 encoding format:
;   Type byte: 0x03 (inline=0, type=0b11)
;   Data: byte-reversed f32 bits encoded as gob uint
; ============================================================================
func @gdp_encode_float32(%f: f32) -> void {
entry:
  ; 1. Bitcast f32 to u32
  %bits = bitcast %f

  ; 2. Byte-reverse: swap bytes in SPIR-V
  ; Extract bytes from the u32 value
  %byte0 = and %bits, 0xFFu
  %shr_8 = shr %bits, 8u
  %byte1 = and %shr_8, 0xFFu
  %shr_16 = shr %bits, 16u
  %byte2 = and %shr_16, 0xFFu
  %byte3 = shr %bits, 24u

  ; Rebuild in reversed order
  %b1_shift = shl %byte2, 8u
  %b2_shift = shl %byte1, 16u
  %b3_shift = shl %byte0, 24u

  %temp1 = or %byte3, %b1_shift
  %temp2 = or %temp1, %b2_shift
  %reversed = or %temp2, %b3_shift

  ; 3. Determine byte count for gob encoding
  %lt_100 = ucmp.lt %reversed, 0x100u
  %lt_10000 = ucmp.lt %reversed, 0x10000u
  %lt_1000000 = ucmp.lt %reversed, 0x1000000u

  ; Select byte count using nested selects
  %count_if_3_or_4 = select %lt_1000000, 3u, 4u
  %count_if_2_or_more = select %lt_10000, 2u, %count_if_3_or_4
  %byte_count = select %lt_100, 1u, %count_if_2_or_more

  ; Negated count for gob encoding
  %negated_count = sub 0u, %byte_count
  %negated_count_byte = and %negated_count, 0xFFu

  ; Extract bytes from reversed value for big-endian gob encoding
  %rev_byte0 = and %reversed, 0xFFu
  %rev_shr_8 = shr %reversed, 8u
  %rev_byte1 = and %rev_shr_8, 0xFFu
  %rev_shr_16 = shr %reversed, 16u
  %rev_byte2 = and %rev_shr_16, 0xFFu
  %rev_byte3 = shr %reversed, 24u

  ; Pack into first word: [0x03, negated_count, rev_byte3, rev_byte2]
  %word0_b1 = shl %negated_count_byte, 8u
  %word0_b2 = shl %rev_byte3, 16u
  %word0_b3 = shl %rev_byte2, 24u

  %word0_temp1 = or 0x03u, %word0_b1
  %word0_temp2 = or %word0_temp1, %word0_b2
  %word0 = or %word0_temp2, %word0_b3

  ; Pack into second word: [rev_byte1, rev_byte0, 0x00, 0x00]
  %word1_b1 = shl %rev_byte0, 8u
  %word1 = or %rev_byte1, %word1_b1

  ; === Reserve 2 words with max_loops check and wrap-to-zero logic ===
  ; Get pointers
  %write_head_ptr = gep[ptr[global]<u32>] @gdp_buffer, 0u, stride=4
  %max_loops_ptr = gep[ptr[global]<u32>] @gdp_buffer, 2u, stride=4

  ; Load max_loops
  %max_loops = load %max_loops_ptr

  ; Atomic load current write_head to check if over limit
  %current_write_head = atomic.load %write_head_ptr ordering=acq_rel scope=device

  ; Calculate loop count: current_write_head / ring_size
  %current_loop = udiv %current_write_head, 4093u

  ; Check if we're over the limit
  %is_full = ucmp.ge %current_loop, %max_loops
  br_if %is_full, full_exit, check_wrap, check_wrap

check_wrap:
  ; Calculate ring position
  %ring_pos = urem %current_write_head, 4093u

  ; Check if allocation would cross boundary: ring_pos + count > ring_size
  %pos_plus_count = add %ring_pos, 2u
  %would_cross = ucmp.gt %pos_plus_count, 4093u

  br_if %would_cross, wrap_to_zero, normal_reserve, write_data

wrap_to_zero:
  ; Skip to next ring: increment by (ring_size - ring_pos) + count
  %skip_amount = sub 4093u, %ring_pos
  %total_skip = add %skip_amount, 2u
  %skipped_pos = atomic.rmw add %write_head_ptr, %total_skip ordering=acq_rel scope=device
  ; After skip, we're at position 0 in the ring
  br write_data

normal_reserve:
  ; Normal allocation: atomically increment and get position
  %global_pos = atomic.rmw add %write_head_ptr, 2u ordering=acq_rel scope=device
  %normal_index = urem %global_pos, 4093u
  br write_data

write_data:
  ; Phi to get the starting index
  %start_index = phi u32 [0u, wrap_to_zero], [%normal_index, normal_reserve]

  ; Calculate actual buffer indices (add 3 for header)
  %data_index0 = add %start_index, 3u
  %index_plus_1 = add %start_index, 1u
  %index_plus_1_mod = urem %index_plus_1, 4093u
  %data_index1 = add %index_plus_1_mod, 3u

  ; Get element pointers and store
  %ptr0 = gep[ptr[global]<u32>] @gdp_buffer, %data_index0, stride=4
  %ptr1 = gep[ptr[global]<u32>] @gdp_buffer, %data_index1, stride=4
  store %ptr0, %word0
  store %ptr1, %word1
  ret

full_exit:
  ; Buffer full, skip write
  ret
}

; ============================================================================
; gdp_encode_uint: Encode an unsigned integer into the GDP ring buffer
;
; Arguments:
;   %value: u32 - The unsigned integer to encode
;
; GDP Uint encoding format:
;   For small values (0-63): single byte with inline value
;   For larger values: type byte 0x00 + gob-encoded uint
; ============================================================================
func @gdp_encode_uint(%value: u32) -> void {
entry:
  ; Check if value fits in inline encoding (0-63)
  %is_small = ucmp.lt %value, 64u

  ; Both branches eventually return, so we need a dummy merge block
  ; For SPIR-V structured CFG, use encode_inline as merge since it's the first branch
  br_if %is_small, encode_inline, encode_full, encode_inline

encode_inline:
  ; Inline encoding: shift value left by 2
  %inline_word = shl %value, 2u

  ; Reserve 1 word with max_loops check (no wrap-to-zero needed for single word)
  %write_head_ptr = gep[ptr[global]<u32>] @gdp_buffer, 0u, stride=4
  %max_loops_ptr = gep[ptr[global]<u32>] @gdp_buffer, 2u, stride=4
  %max_loops = load %max_loops_ptr
  %current_write_head = atomic.load %write_head_ptr ordering=acq_rel scope=device
  %current_loop = udiv %current_write_head, 4093u
  %is_full = ucmp.ge %current_loop, %max_loops
  br_if %is_full, exit_inline, reserve_inline, reserve_inline

reserve_inline:
  %start_index_inline = atomic.rmw add %write_head_ptr, 1u ordering=acq_rel scope=device
  %index_raw = urem %start_index_inline, 4093u
  %index = add %index_raw, 3u
  %ptr = gep[ptr[global]<u32>] @gdp_buffer, %index, stride=4
  store %ptr, %inline_word
  ret

exit_inline:
  ret

encode_full:
  ; Full encoding: type byte 0x00 + gob uint
  ; Determine byte count (1-4 bytes for u32)
  %lt_100 = ucmp.lt %value, 0x100u
  %lt_10000 = ucmp.lt %value, 0x10000u
  %lt_1000000 = ucmp.lt %value, 0x1000000u

  %count_if_3_or_4 = select %lt_1000000, 3u, 4u
  %count_if_2_or_more = select %lt_10000, 2u, %count_if_3_or_4
  %byte_count = select %lt_100, 1u, %count_if_2_or_more

  ; Negated count for gob encoding
  %negated_count = sub 0u, %byte_count
  %negated_count_byte = and %negated_count, 0xFFu

  ; Extract bytes from value (big-endian)
  %byte0 = and %value, 0xFFu
  %shr_8 = shr %value, 8u
  %byte1 = and %shr_8, 0xFFu
  %shr_16 = shr %value, 16u
  %byte2 = and %shr_16, 0xFFu
  %byte3 = shr %value, 24u

  ; Pack into first word: [0x00, negated_count, byte3, byte2]
  %word0_b1 = shl %negated_count_byte, 8u
  %word0_b2 = shl %byte3, 16u
  %word0_b3 = shl %byte2, 24u

  %word0_temp1 = or 0x00u, %word0_b1
  %word0_temp2 = or %word0_temp1, %word0_b2
  %word0 = or %word0_temp2, %word0_b3

  ; Pack into second word: [byte1, byte0, 0x00, 0x00]
  %word1_b1 = shl %byte0, 8u
  %word1 = or %byte1, %word1_b1

  ; Reserve 2 words with wrap-to-zero logic (same as float32)
  %write_head_ptr2 = gep[ptr[global]<u32>] @gdp_buffer, 0u, stride=4
  %max_loops_ptr2 = gep[ptr[global]<u32>] @gdp_buffer, 2u, stride=4
  %max_loops2 = load %max_loops_ptr2
  %current_write_head2 = atomic.load %write_head_ptr2 ordering=acq_rel scope=device
  %current_loop2 = udiv %current_write_head2, 4093u
  %is_full2 = ucmp.ge %current_loop2, %max_loops2
  br_if %is_full2, full_exit2, check_wrap2, check_wrap2

check_wrap2:
  %ring_pos2 = urem %current_write_head2, 4093u
  %pos_plus_count2 = add %ring_pos2, 2u
  %would_cross2 = ucmp.gt %pos_plus_count2, 4093u
  br_if %would_cross2, wrap_to_zero2, normal_reserve2, write_data2

wrap_to_zero2:
  %skip_amount2 = sub 4093u, %ring_pos2
  %total_skip2 = add %skip_amount2, 2u
  %skipped_pos2 = atomic.rmw add %write_head_ptr2, %total_skip2 ordering=acq_rel scope=device
  br write_data2

normal_reserve2:
  %global_pos2 = atomic.rmw add %write_head_ptr2, 2u ordering=acq_rel scope=device
  %normal_index2 = urem %global_pos2, 4093u
  br write_data2

write_data2:
  %start_index2 = phi u32 [0u, wrap_to_zero2], [%normal_index2, normal_reserve2]
  %data_index0_2 = add %start_index2, 3u
  %index_plus_1_2 = add %start_index2, 1u
  %index_plus_1_mod2 = urem %index_plus_1_2, 4093u
  %data_index1_2 = add %index_plus_1_mod2, 3u
  %ptr0_2 = gep[ptr[global]<u32>] @gdp_buffer, %data_index0_2, stride=4
  %ptr1_2 = gep[ptr[global]<u32>] @gdp_buffer, %data_index1_2, stride=4
  store %ptr0_2, %word0
  store %ptr1_2, %word1
  ret

full_exit2:
  ret
}

; ============================================================================
; gdp_encode_string_local: Encode a local string literal into the GDP ring buffer
;
; Arguments:
;   %str_arr: ptr[local]<[16; u32]> - Pointer to fixed-size array of 16 u32 words (max 64 bytes)
;   %str_len: u32 - Length of string in bytes (must be <= 64)
;
; The string is stored as packed u32 words in little-endian byte order.
; To extract byte i: load word at (i / 4), shift right by ((i % 4) * 8), mask with 0xFF
;
; GDP String encoding format:
;   Type byte: 0x02 (inline=0, type=0b10)
;   Length: gob-encoded uint
;   Data: UTF-8 bytes
; ============================================================================
func @gdp_encode_string_local(%str_arr: ptr[local]<[16; u32]>, %str_len: u32) -> void {
entry:
  ; For strings < 64 bytes: type byte is (length << 2) | 0x02
  %is_short = ucmp.lt %str_len, 64u
  br_if %is_short, encode_short, encode_exit, encode_exit

encode_short:
  ; Type byte: (str_len << 2) | 0x02
  %len_shifted = shl %str_len, 2u
  %type_byte = or %len_shifted, 0x02u

  ; Calculate total bytes: 1 (type) + str_len
  %total_bytes = add %str_len, 1u

  ; Calculate words needed: (total_bytes + 3) / 4
  %bytes_rounded = add %total_bytes, 3u
  %total_words = udiv %bytes_rounded, 4u

  ; Reserve space
  %write_head_ptr = gep[ptr[global]<u32>] @gdp_buffer, 0u, stride=4
  %start_pos = atomic.rmw add %write_head_ptr, %total_words ordering=acq_rel scope=device

  ; Calculate ring position
  %ring_pos = urem %start_pos, 4093u

  ; Initialize loop: byte_idx = 0, word_idx = 0, current_word = type_byte
  br pack_loop

pack_loop [loop merge=finalize, continue=pack_continue]:
  ; Phi: byte_idx, word_idx, current_word, shift
  ; Values come from entry (encode_short) or continue block (pack_continue)
  %byte_idx = phi u32 [0u, encode_short], [%cont_byte_idx, pack_continue]
  %word_idx = phi u32 [0u, encode_short], [%cont_word_idx, pack_continue]
  %current_word = phi u32 [%type_byte, encode_short], [%cont_current_word, pack_continue]
  %shift = phi u32 [8u, encode_short], [%cont_shift, pack_continue]

  ; Check if we're done with all bytes
  ; No merge label needed - the loop header's OpLoopMerge handles structured CFG
  %done = ucmp.ge %byte_idx, %str_len
  br_if %done, finalize, pack_byte

pack_byte:
  ; Extract byte from packed u32 string data
  ; word_index = byte_idx / 4, byte_offset = byte_idx % 4
  %src_word_idx = udiv %byte_idx, 4u
  %byte_offset = urem %byte_idx, 4u
  %byte_shift = shl %byte_offset, 3u  ; byte_offset * 8

  ; Load word containing the byte - GEP on the array pointer
  %src_word_ptr = gep[ptr[local]<u32>] %str_arr, %src_word_idx, stride=4
  %src_word = load %src_word_ptr

  ; Extract byte: (word >> shift) & 0xFF
  %byte_shifted_down = shr %src_word, %byte_shift
  %byte_val = and %byte_shifted_down, 0xFFu

  ; Shift byte and OR into current_word
  %byte_shifted = shl %byte_val, %shift
  %updated_word = or %current_word, %byte_shifted

  ; Increment byte index
  %next_byte_idx = add %byte_idx, 1u

  ; Calculate next shift (shift + 8)
  %next_shift = add %shift, 8u

  ; Check if word is full (shift == 32)
  %word_full = ucmp.eq %next_shift, 32u
  br_if %word_full, write_word, pack_continue_normal, pack_continue_normal

pack_continue_normal:
  ; Continue without writing - carry forward updated values
  br pack_continue

write_word:
  ; Write current_word to buffer
  %buffer_idx_base = add %ring_pos, %word_idx
  %buffer_idx_wrapped = urem %buffer_idx_base, 4093u
  %buffer_idx = add %buffer_idx_wrapped, 3u
  %word_ptr = gep[ptr[global]<u32>] @gdp_buffer, %buffer_idx, stride=4
  store %word_ptr, %updated_word

  ; Increment word index
  %next_word_idx = add %word_idx, 1u

  ; Go through continue block to loop back (SPIR-V requires single back-edge)
  br pack_continue

pack_continue:
  ; Merge values from both paths to feed into loop header
  %cont_byte_idx = phi u32 [%next_byte_idx, pack_continue_normal], [%next_byte_idx, write_word]
  %cont_word_idx = phi u32 [%word_idx, pack_continue_normal], [%next_word_idx, write_word]
  %cont_current_word = phi u32 [%updated_word, pack_continue_normal], [0u, write_word]
  %cont_shift = phi u32 [%next_shift, pack_continue_normal], [0u, write_word]
  br pack_loop

finalize:
  ; If there's a partial word, write it
  %has_partial = ucmp.ne %shift, 0u
  br_if %has_partial, write_final, finalize_done, finalize_done

write_final:
  %final_idx_base = add %ring_pos, %word_idx
  %final_idx_wrapped = urem %final_idx_base, 4093u
  %final_idx = add %final_idx_wrapped, 3u
  %final_ptr = gep[ptr[global]<u32>] @gdp_buffer, %final_idx, stride=4
  store %final_ptr, %current_word
  br finalize_done

finalize_done:
  ret

encode_exit:
  ret
}
