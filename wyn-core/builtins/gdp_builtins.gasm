; GDP (GPU Debug Protocol) Builtin Functions
; Simple encoding format - no gob complexity
;
; Word 0 (header): TTTTTTTT SSSSSSSS SSSSSSSS SSSSSSSS
;   - Byte 0 (bits 0-7): Type tag (0x00=u32, 0x01=i32, 0x02=string, 0x03=f32)
;   - Bytes 1-3 (bits 8-31): Size in data words (not including header)
;
; Scalars (u32/i32/f32): header + 1 raw value word
; Strings: header + N padded data words

; Global variables for GDP ring buffer
; The ring buffer has the following structure:
; - Word 0: write_head (unbounded atomic counter)
; - Word 1: read_head (for future use)
; - Word 2: max_loops (configured limit to prevent infinite wraparound)
; - Words 3-4095: data buffer (4093 u32 words)
global @gdp_buffer : ptr[global]<u32>

; Constants for ring buffer
; RING_BUFFER_DATA_SIZE = 4093
; RING_BUFFER_HEADER_SIZE = 3

; ============================================================================
; gdp_write_two_words: Write two words to the GDP buffer with wrap handling
; ============================================================================
func @gdp_write_two_words(%word0: u32, %word1: u32) -> void {
entry:
  %write_head_ptr = gep[ptr[global]<u32>] @gdp_buffer, 0u, stride=4
  %max_loops_ptr = gep[ptr[global]<u32>] @gdp_buffer, 2u, stride=4
  %max_loops = load %max_loops_ptr
  %current_write_head = atomic.load %write_head_ptr ordering=acq_rel scope=device
  %current_loop = udiv %current_write_head, 4093u
  %is_full = ucmp.ge %current_loop, %max_loops
  br_if %is_full, full_exit, check_wrap, check_wrap

check_wrap:
  %ring_pos = urem %current_write_head, 4093u
  %pos_plus_count = add %ring_pos, 2u
  %would_cross = ucmp.gt %pos_plus_count, 4093u
  br_if %would_cross, wrap_to_zero, normal_reserve, write_data

wrap_to_zero:
  %skip_amount = sub 4093u, %ring_pos
  %total_skip = add %skip_amount, 2u
  %skipped_pos = atomic.rmw add %write_head_ptr, %total_skip ordering=acq_rel scope=device
  br write_data

normal_reserve:
  %global_pos = atomic.rmw add %write_head_ptr, 2u ordering=acq_rel scope=device
  %normal_index = urem %global_pos, 4093u
  br write_data

write_data:
  %start_index = phi u32 [0u, wrap_to_zero], [%normal_index, normal_reserve]
  %data_index0 = add %start_index, 3u
  %index_plus_1 = add %start_index, 1u
  %index_plus_1_mod = urem %index_plus_1, 4093u
  %data_index1 = add %index_plus_1_mod, 3u
  %ptr0 = gep[ptr[global]<u32>] @gdp_buffer, %data_index0, stride=4
  %ptr1 = gep[ptr[global]<u32>] @gdp_buffer, %data_index1, stride=4
  store %ptr0, %word0
  store %ptr1, %word1
  ret

full_exit:
  ret
}

; ============================================================================
; gdp_encode_float32: Encode a f32 value into the GDP ring buffer
;
; Format: [header, bits]
;   header = 0x03 | (1 << 8)  (type=f32, size=1)
;   bits = bitcast f32 to u32
; ============================================================================
func @gdp_encode_float32(%f: f32) -> void {
entry:
  %bits = bitcast %f
  %header = or 0x03u, 0x100u
  call @gdp_write_two_words(%header, %bits)
  ret
}

; ============================================================================
; gdp_encode_uint: Encode an unsigned integer into the GDP ring buffer
;
; Format: [header, value]
;   header = 0x00 | (1 << 8)  (type=u32, size=1)
;   value = raw u32
; ============================================================================
func @gdp_encode_uint(%value: u32) -> void {
entry:
  %header = or 0x00u, 0x100u
  call @gdp_write_two_words(%header, %value)
  ret
}

; ============================================================================
; gdp_encode_int32: Encode a signed i32 value into the GDP ring buffer
;
; Format: [header, bits]
;   header = 0x01 | (1 << 8)  (type=i32, size=1)
;   bits = bitcast i32 to u32
; ============================================================================
func @gdp_encode_int32(%value: i32) -> void {
entry:
  %bits = bitcast %value
  %header = or 0x01u, 0x100u
  call @gdp_write_two_words(%header, %bits)
  ret
}

; ============================================================================
; gdp_encode_string_local: Encode a local string literal into the GDP ring buffer
;
; Arguments:
;   %str_arr: ptr[local]<[16; u32]> - Pointer to fixed-size array of 16 u32 words (max 64 bytes)
;   %str_len: u32 - Length of string in bytes (must be <= 64)
;
; Format: [header, data words...]
;   header = 0x02 | (word_count << 8)
;   data = string bytes packed into u32s, with at least 1 trailing zero
;
; String bytes are packed little-endian: first byte in bits 0-7, etc.
; If string length is multiple of 4, an extra word of zeros is added.
; ============================================================================
func @gdp_encode_string_local(%str_arr: ptr[local]<[16; u32]>, %str_len: u32) -> void {
entry:
  ; Calculate word count: (str_len + 4) / 4
  ; This ensures at least 1 trailing zero byte
  %len_plus_4 = add %str_len, 4u
  %word_count = udiv %len_plus_4, 4u

  ; Build header: type=0x02, size=word_count
  %size_shifted = shl %word_count, 8u
  %header = or 0x02u, %size_shifted

  ; Total words to reserve: 1 (header) + word_count
  %total_words = add %word_count, 1u

  ; Reserve space in ring buffer
  %write_head_ptr = gep[ptr[global]<u32>] @gdp_buffer, 0u, stride=4
  %max_loops_ptr = gep[ptr[global]<u32>] @gdp_buffer, 2u, stride=4
  %max_loops = load %max_loops_ptr
  %current_write_head = atomic.load %write_head_ptr ordering=acq_rel scope=device
  %current_loop = udiv %current_write_head, 4093u
  %is_full = ucmp.ge %current_loop, %max_loops
  br_if %is_full, full_exit, reserve, reserve

reserve:
  %start_pos = atomic.rmw add %write_head_ptr, %total_words ordering=acq_rel scope=device
  %ring_pos = urem %start_pos, 4093u

  ; Write header
  %header_idx = add %ring_pos, 3u
  %header_ptr = gep[ptr[global]<u32>] @gdp_buffer, %header_idx, stride=4
  store %header_ptr, %header

  ; Write string data words
  ; The source array already has the string packed into u32s
  br write_loop

write_loop [loop merge=done, continue=write_continue]:
  %i = phi u32 [0u, reserve], [%next_i, write_continue]
  %done_cond = ucmp.ge %i, %word_count
  br_if %done_cond, done, write_word

write_word:
  ; Load source word (may be partial/zero for padding)
  %src_ptr = gep[ptr[local]<u32>] %str_arr, %i, stride=4
  %src_word = load %src_ptr

  ; Calculate destination index
  %data_offset = add %i, 1u
  %dest_ring_idx = add %ring_pos, %data_offset
  %dest_ring_wrapped = urem %dest_ring_idx, 4093u
  %dest_idx = add %dest_ring_wrapped, 3u
  %dest_ptr = gep[ptr[global]<u32>] @gdp_buffer, %dest_idx, stride=4
  store %dest_ptr, %src_word
  br write_continue

write_continue:
  %next_i = add %i, 1u
  br write_loop

done:
  ret

full_exit:
  ret
}
