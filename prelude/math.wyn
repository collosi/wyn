module type from_prim = {
type t
val i8	: 	i8 -> t
val i16	: 	i16 -> t
val i32	: 	i32 -> t
val i64	: 	i64 -> t
val u8	: 	u8 -> t
val u16	: 	u16 -> t
val u32	: 	u32 -> t
val u64	: 	u64 -> t
val f16	: 	f16 -> t
val f32	: 	f32 -> t
val f64	: 	f64 -> t
val bool	: 	bool -> t
}
module type numeric = {
include from_prim
val (+)	: 	t -> t -> t
val (-)	: 	t -> t -> t
val (*)	: 	t -> t -> t
val (/)	: 	t -> t -> t
val (%)	: 	t -> t -> t
val (**)	: 	t -> t -> t
val to_i64	: 	t -> i64
val (==)	: 	t -> t -> bool
val (<)	: 	t -> t -> bool
val (>)	: 	t -> t -> bool
val (<=)	: 	t -> t -> bool
val (>=)	: 	t -> t -> bool
val (!=)	: 	t -> t -> bool
val neg	: 	t -> t
val max	: 	t -> t -> t
val min	: 	t -> t -> t
val abs	: 	t -> t
val sgn	: 	t -> t
val highest	: 	t
val lowest	: 	t
val sum	 [n]: 	[n]t -> t
val product	 [n]: 	[n]t -> t
val maximum	 [n]: 	[n]t -> t
val minimum	 [n]: 	[n]t -> t
}
module type integral = {
include numeric
val (//)	: 	t -> t -> t
val (%%)	: 	t -> t -> t
val (&)	: 	t -> t -> t
val (|)	: 	t -> t -> t
val (^)	: 	t -> t -> t
val not	: 	t -> t
val (<<)	: 	t -> t -> t
val (>>)	: 	t -> t -> t
val (>>>)	: 	t -> t -> t
val num_bits	: 	i32
val get_bit	: 	i32 -> t -> i32
val set_bit	: 	i32 -> t -> i32 -> t
val popc	: 	t -> i32
val mul_hi	: 	(x: t) -> (y: t) -> t
val mad_hi	: 	(a: t) -> (b: t) -> (c: t) -> t
val clz	: 	t -> i32
val ctz	: 	t -> i32
}
module type real = {
include numeric
val recip	: 	t -> t
val from_fraction	: 	i64 -> i64 -> t
val to_i64	: 	t -> i64
val to_f64	: 	t -> f64
val sqrt	: 	t -> t
val rsqrt	: 	t -> t
val cbrt	: 	t -> t
val exp	: 	t -> t
val sin	: 	t -> t
val cos	: 	t -> t
val tan	: 	t -> t
val sinpi	: 	t -> t
val cospi	: 	t -> t
val tanpi	: 	t -> t
val asin	: 	t -> t
val acos	: 	t -> t
val atan	: 	t -> t
val asinpi	: 	t -> t
val acospi	: 	t -> t
val atanpi	: 	t -> t
val sinh	: 	t -> t
val cosh	: 	t -> t
val tanh	: 	t -> t
val asinh	: 	t -> t
val acosh	: 	t -> t
val atanh	: 	t -> t
val atan2	: 	t -> t -> t
val atan2pi	: 	t -> t -> t
val hypot	: 	t -> t -> t
val gamma	: 	t -> t
val lgamma	: 	t -> t
val erf	: 	t -> t
val erfc	: 	t -> t
val lerp	: 	t -> t -> t -> t
val log	: 	t -> t
val log2	: 	t -> t
val log10	: 	t -> t
val log1p	: 	t -> t
val ceil	: 	t -> t
val floor	: 	t -> t
val trunc	: 	t -> t
val round	: 	t -> t
val mad	: 	(a: t) -> (b: t) -> (c: t) -> t
val fma	: 	(a: t) -> (b: t) -> (c: t) -> t
val isinf	: 	t -> bool
val isnan	: 	t -> bool
val inf	: 	t
val nan	: 	t
val pi	: 	t
val e	: 	t
}
module type float = {
include real
type int_t
val from_bits	: 	int_t -> t
val to_bits	: 	t -> int_t
val num_bits	: 	i32
val get_bit	: 	i32 -> t -> i32
val set_bit	: 	i32 -> t -> i32 -> t
val epsilon	: 	t
val nextafter	: 	(x: t) -> (y: t) -> t
val ldexp	: 	t -> i32 -> t
val copysign	: 	(x: t) -> (y: t) -> t
}
module bool	: 	from_prim with t = bool
module i8	: 	(integral with t = i8)
module i16	: 	(integral with t = i16)
module i32	: 	(integral with t = i32)
module i64	: 	(integral with t = i64)
module u8	: 	(integral with t = u8)
module u16	: 	(integral with t = u16)
module u32	: 	(integral with t = u32)
module u64	: 	(integral with t = u64)
module f64	: 	(float with t = f64 with int_t = u64)
module f32	: 	(float with t = f32 with int_t = u32) = {
  type t = f32
  type int_t = u32

  def i8 (x: i8): t = __builtin_f32_from_i8 x
  def i16 (x: i16): t = __builtin_f32_from_i16 x
  def i32 (x: i32): t = __builtin_f32_from_i32 x
  def i64 (x: i64): t = __builtin_f32_from_i64 x
  def u8 (x: u8): t = __builtin_f32_from_u8 x
  def u16 (x: u16): t = __builtin_f32_from_u16 x
  def u32 (x: u32): t = __builtin_f32_from_u32 x
  def u64 (x: u64): t = __builtin_f32_from_u64 x
  def f16 (x: f16): t = __builtin_f32_from_f16 x
  def f32 (x: f32): t = x
  def f64 (x: f64): t = __builtin_f32_from_f64 x
  def bool (x: bool): t = if x then 1.0f32 else 0.0f32

  def (+) (x: t) (y: t): t = x + y
  def (-) (x: t) (y: t): t = x - y
  def (*) (x: t) (y: t): t = x * y
  def (/) (x: t) (y: t): t = x / y
  def (%) (x: t) (y: t): t = x % y
  def (**) (x: t) (y: t): t = f32.pow x y

  def to_i64 (x: t): i64 = __builtin_f32_to_i64 x

  def (==) (x: t) (y: t): bool = x == y
  def (<) (x: t) (y: t): bool = x < y
  def (>) (x: t) (y: t): bool = x > y
  def (<=) (x: t) (y: t): bool = x <= y
  def (>=) (x: t) (y: t): bool = x >= y
  def (!=) (x: t) (y: t): bool = x != y

  def neg (x: t): t = 0.0f32 - x
  def max (x: t) (y: t): t = f32.max x y
  def min (x: t) (y: t): t = f32.min x y
  def abs (x: t): t = f32.abs x
  def sgn (x: t): t = if f32.isnan x then x else if x > 0.0f32 then 1.0f32 else if x < 0.0f32 then (0.0f32 - 1.0f32) else 0.0f32

  def highest: t = 1.0f32 / 0.0f32
  def lowest: t = (0.0f32 - 1.0f32) / 0.0f32

  def sum [n] (arr: [n]t): t = f32.sum arr
  def product [n] (arr: [n]t): t = f32.product arr
  def maximum [n] (arr: [n]t): t = f32.maximum arr
  def minimum [n] (arr: [n]t): t = f32.minimum arr

  def recip (x: t): t = 1.0f32 / x
  def from_fraction (x: i64) (y: i64): t = __builtin_f32_from_i64 x / __builtin_f32_from_i64 y
  def to_f64 (x: t): f64 = x

  def sqrt (x: t): t = f32.sqrt x
  def rsqrt (x: t): t = f32.rsqrt x
  def cbrt (x: t): t = f32.pow x (1.0f32 / 3.0f32)

  def exp (x: t): t = f32.exp x
  def log (x: t): t = f32.log x
  def log2 (x: t): t = f32.log2 x
  def log10 (x: t): t = f32.log x / f32.log 10.0f32
  def log1p (x: t): t = f32.log (1.0f32 + x)

  def sin (x: t): t = f32.sin x
  def cos (x: t): t = f32.cos x
  def tan (x: t): t = f32.tan x
  def asin (x: t): t = f32.asin x
  def acos (x: t): t = f32.acos x
  def atan (x: t): t = f32.atan x

  def pi: t = 3.14159265358979323846f32
  def sinpi (x: t): t = f32.sin (pi * x)
  def cospi (x: t): t = f32.cos (pi * x)
  def tanpi (x: t): t = f32.tan (pi * x)
  def asinpi (x: t): t = f32.asin x / pi
  def acospi (x: t): t = f32.acos x / pi
  def atanpi (x: t): t = f32.atan x / pi

  def sinh (x: t): t = f32.sinh x
  def cosh (x: t): t = f32.cosh x
  def tanh (x: t): t = f32.tanh x
  def asinh (x: t): t = f32.asinh x
  def acosh (x: t): t = f32.acosh x
  def atanh (x: t): t = f32.atanh x

  def atan2 (x: t) (y: t): t = f32.atan2 x y
  def atan2pi (x: t) (y: t): t = f32.atan2 x y / pi
  def hypot (x: t) (y: t): t = f32.sqrt (x * x + y * y)

  def gamma (x: t): t = x
  def lgamma (x: t): t = x
  def erf (x: t): t = x
  def erfc (x: t): t = x

  def lerp (v0: t) (v1: t) (t: t): t = f32.lerp v0 v1 t
  def mad (a: t) (b: t) (c: t): t = a * b + c
  def fma (a: t) (b: t) (c: t): t = f32.fma a b c

  def ceil (x: t): t = f32.ceil x
  def floor (x: t): t = f32.floor x
  def trunc (x: t): t = f32.trunc x
  def round (x: t): t = f32.round x

  def isinf (x: t): bool = f32.isinf x
  def isnan (x: t): bool = f32.isnan x
  def inf: t = 1.0f32 / 0.0f32
  def nan: t = 0.0f32 / 0.0f32
  def e: t = 2.71828182845904523536f32

  def from_bits (x: int_t): t = __builtin_f32_from_bits x
  def to_bits (x: t): int_t = __builtin_f32_to_bits x
  def num_bits: i32 = 32
  def get_bit (bit: i32) (x: t): i32 = i32 0
  def set_bit (bit: i32) (x: t) (b: i32): t = x

  def epsilon: t = 1.1920929e-7f32
  def nextafter (x: t) (y: t): t = x
  def ldexp (x: t) (n: i32): t = x
  def copysign (x: t) (y: t): t = if y < 0.0f32 then (0.0f32 - f32.abs x) else f32.abs x
}
module f16	: 	(float with t = f16 with int_t = u16)
