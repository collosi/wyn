-- Second-Order Array Combinators (SOACs)
-- Based on Futhark's prelude/soacs module

-- Map a function over an array
def map ['a] ['b] [n] (f: a -> b) (xs: [n]a) : [n]b =
  loop (i, acc) = (0, []) while i < n do
    (i + 1, acc ++ [f xs[i]])

-- Map a binary function over two arrays
def map2 ['a] ['b] ['c] [n] (f: a -> b -> c) (xs: [n]a) (ys: [n]b) : [n]c =
  loop (i, acc) = (0, []) while i < n do
    (i + 1, acc ++ [f xs[i] ys[i]])

-- Reduce an array with a binary associative operator and neutral element
def reduce ['a] [n] (op: a -> a -> a) (ne: a) (xs: [n]a) : a =
  loop (i, acc) = (0, ne) while i < n do
    (i + 1, op acc xs[i])

-- Scan (prefix sum) with a binary associative operator and neutral element
def scan ['a] [n] (op: a -> a -> a) (ne: a) (xs: [n]a) : [n]a =
  loop (i, acc_val, acc_arr) = (0, ne, []) while i < n do
    let new_val = op acc_val xs[i] in
    (i + 1, new_val, acc_arr ++ [new_val])

-- Filter elements that satisfy a predicate
def filter ['a] [n] (p: a -> bool) (xs: [n]a) : []a =
  loop (i, acc) = (0, []) while i < n do
    if p xs[i]
    then (i + 1, acc ++ [xs[i]])
    else (i + 1, acc)
