name         ::= lowercase constituent* | "_" constituent*
constituent  ::= letter | digit | "_" | "'"
quals        ::= (name ".")+
qualname     ::= name | quals name
symbol       ::= symstartchar symchar*
qualsymbol   ::= symbol | quals symbol | "`" qualname "`"
fieldid      ::= decimal | name
symstartchar ::= "+" | "-" | "*" | "/" | "%" | "=" | "!" | ">" | "<" | "|" | "&" | "^"
symchar      ::= symstartchar | "."
constructor  ::= uppercase constituent*
lowercase    ::= "a"..."z"
uppercase    ::= "A"..."Z"
letter       ::= lowercase | uppercase


literal ::= intnumber | floatnumber | "true" | "false"


int_type   ::= "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64"
float_type ::= "f16" | "f32" | "f64"


intnumber   ::= (decimal | hexadecimal | binary) [int_type]
decimal     ::= decdigit (decdigit |"_")*
hexadecimal ::= 0 ("x" | "X") hexdigit (hexdigit |"_")*
binary      ::= 0 ("b" | "B") bindigit (bindigit | "_")*


floatnumber      ::= (pointfloat | exponentfloat | hexadecimalfloat) [float_type]
pointfloat       ::= [intpart] fraction
exponentfloat    ::= (intpart | pointfloat) exponent
hexadecimalfloat ::= 0 ("x" | "X") hexintpart hexfraction ("p"|"P") ["+" | "-"] decdigit+
intpart          ::= decdigit (decdigit |"_")*
fraction         ::= "." decdigit (decdigit |"_")*
hexintpart       ::= hexdigit (hexdigit | "_")*
hexfraction      ::= "." hexdigit (hexdigit |"_")*
exponent         ::= ("e" | "E") ["+" | "-"] decdigit+


decdigit ::= "0"..."9"
hexdigit ::= decdigit | "a"..."f" | "A"..."F"
bindigit ::= "0" | "1"


type ::= qualname
         | array_type
         | tuple_type
         | record_type
         | sum_type
         | function_type
         | type_application
         | existential_size


tuple_type ::= "(" ")" | "(" type ("," type)+ [","] ")"


array_type ::= "[" [exp] "]" type


sum_type ::= constructor type* ("|" constructor type*)*


record_type ::= "{" "}" | "{" fieldid ":" type ("," fieldid ":" type)* [","] "}"


type_application ::= type type_arg | "*" type
type_arg         ::= "[" [dim] "]" | type


function_type ::= param_type "->" type
param_type    ::= type | "(" name ":" type ")"


stringlit  ::= '"' stringchar* '"'
stringchar ::= <any source character except "\" or newline or double quotes>
charlit    ::= "'" char "'"
char       ::= <any source character except "\" or newline or single quotes>


existential_size ::= "?" ("[" name "]")+ "." type


dec ::= val_bind | type_bind | mod_bind | mod_type_bind
        | "open" mod_exp
        | "import" stringlit
        | "local" dec
        | "#[" attr "]" dec


val_bind ::= ("def" | "entry" | "let") (name | "(" symbol ")") type_param* pat* [":" type] "=" exp
             | ("def" | "entry" | "let") pat symbol pat [":" type] "=" exp

type_bind  ::= ("type" | "type^" | "type~") name type_param* "=" type
type_param ::= "[" name "]" | "'" name | "'~" name | "'^" name




atom        ::= literal
                | qualname ("." fieldid)*
                | stringlit
                | charlit
                | "(" ")"
                | "(" exp ")" ("." fieldid)*
                | "(" exp ("," exp)+ [","] ")"
                | "{" "}"
                | "{" field ("," field)* [","] "}"
                | qualname slice
                | "(" exp ")" slice
                | quals "." "(" exp ")"
                | "[" exp ("," exp)* [","] "]"
                | "(" qualsymbol ")"
                | "(" exp qualsymbol ")"
                | "(" qualsymbol exp ")"
                | "(" ( "." field )+ ")"
                | "(" "." slice ")"
                | "???"
exp         ::= atom
                | exp qualsymbol exp
                | exp exp
                | "!" exp
                | "-" exp
                | constructor exp*
                | exp ":" type
                | exp ":>" type
                | exp [ ".." exp ] "..." exp
                | exp [ ".." exp ] "..<" exp
                | exp [ ".." exp ] "..>" exp
                | "if" exp "then" exp "else" exp
                | "let" size* pat "=" exp "in" exp
                | "let" name slice "=" exp "in" exp
                | "let" name type_param* pat+ [":" type] "=" exp "in" exp
                | "(" "\" pat+ [":" type] "->" exp ")"
                | "loop" pat ["=" exp] loopform "do" exp
                | "#[" attr "]" exp
                | "unsafe" exp
                | "assert" atom exp
                | exp "with" slice "=" exp
                | exp "with" fieldid ("." fieldid)* "=" exp
                | "match" exp ("case" pat "->" exp)+
slice       ::= "[" index ("," index)* [","] "]"
field       ::= fieldid "=" exp
                | name
size        ::= "[" name "]"
pat         ::= name
                | pat_literal
                | "_"
                | "(" ")"
                | "(" pat ")"
                | "(" pat ("," pat)+ [","] ")"
                | "{" "}"
                | "{" fieldid ["=" pat] ("," fieldid ["=" pat])* [","] "}"
                | constructor pat*
                | pat ":" type
                | "#[" attr "]" pat
pat_literal ::= [ "-" ] intnumber
                | [ "-" ] floatnumber
                | charlit
                | "true"
                | "false"
loopform    ::= "for" name "<" exp
                | "for" pat "in" exp
                | "while" exp
index       ::= exp [":" [exp]] [":" [exp]]
                | [exp] ":" exp [":" [exp]]
                | [exp] [":" exp] ":" [exp]


mod_bind      ::= "module" name mod_param* "=" [":" mod_type_exp] "=" mod_exp
mod_param     ::= "(" name ":" mod_type_exp ")"
mod_type_bind ::= "module" "type" name "=" mod_type_exp


mod_exp ::= qualname
            | mod_exp ":" mod_type_exp
            | "\" "(" mod_param* ")" [":" mod_type_exp] "->" mod_exp
            | mod_exp mod_exp
            | "(" mod_exp ")"
            | "{" dec* "}"
            | "import" stringlit


mod_type_exp ::= qualname
                 | "{" spec* "}"
                 | mod_type_exp "with" qualname type_param* "=" type
                 | "(" mod_type_exp ")"
                 | "(" name ":" mod_type_exp ")" "->" mod_type_exp
                 | mod_type_exp "->" mod_type_exp


spec ::= "val" name type_param* ":" type
         | "val" "(" symbol ")" ":" type
         | "val" symbol type_param* ":" type
         | ("type" | "type^" | "type~") name type_param* "=" type
         | ("type" | "type^" | "type~") name type_param*
         | "module" name ":" mod_type_exp
         | "include" mod_type_exp
         | "#[" attr "]" spec


attr ::= name
         | decimal
         | name "(" [attr ("," attr)* [","]] ")"



=== AMBIGUITIES

The above grammar contains some ambiguities, which in the concrete implementation is resolved via a combination of lexer and grammar transformations. For ease of understanding, they are presented here in natural text.

An expression x.y may either be a reference to the name y in the module x, or the field y in the record x. Modules and values occupy the same name space, so this is disambiguated by whether x is a value or module.

A type ascription (exp : type) cannot appear as an array index, as it conflicts with the syntax for slicing.

In f [x], there is an ambiguity between indexing the array f at position x, or calling the function f with the singleton array x. We resolve this the following way:

If there is a space between f and the opening bracket, it is treated as a function application.
Otherwise, it is an array index operation.
An expression (-x) is parsed as the variable x negated and enclosed in parentheses, rather than an operator section partially applying the infix operator -.

Prefix operators bind more tighly than infix operators. Note that the only prefix operators are the builtin ! and -, and more cannot be defined. In particular, a user-defined operator beginning with ! binds as !=, as on the table below, not as the prefix operator !

Function and type application binds more tightly than infix operators.

#foo #bar is interpreted as a constructor with a #bar payload, not as applying #foo to #bar (the latter would be semantically invalid anyway).

Attributes bind less tightly than any other syntactic construct.

A type application pt [n]t is parsed as an application of the type constructor pt to the size argument [n] and the type t. To pass a single array-typed parameter, enclose it in parens.

The bodies of let, if, and loop extend as far to the right as possible, as does the expression guarded by an assert.

The following table describes the precedence and associativity of infix operators in both expressions and type expressions. All operators in the same row have the same precedence. The rows are listed in increasing order of precedence. Note that not all operators listed here are used in expressions; nevertheless, they are still used for resolving ambiguities.

Associativity Operators
left          ,
left          :, :>
left          `symbol`
left          ||
left          &&
left          <= >= > < == != ! =
left          & ^ |
left          << >>
left          + -
left          * / % // %%
left          |>
right         <|
right         ->
left          **
left          juxtaposition
