-- Spinning Cube Demo in Wyn
-- A colorful cube with different colors on each face

-- ============================================================================
-- Cube Geometry Data
-- ============================================================================

-- Cube vertices (8 corners)
def cube_vertices: [8]vec3 = 
  [vec3(-1.0f32, -1.0f32, -1.0f32),  -- 0: left,  bottom, back
   vec3( 1.0f32, -1.0f32, -1.0f32),  -- 1: right, bottom, back
   vec3( 1.0f32,  1.0f32, -1.0f32),  -- 2: right, top,    back
   vec3(-1.0f32,  1.0f32, -1.0f32),  -- 3: left,  top,    back
   vec3(-1.0f32, -1.0f32,  1.0f32),  -- 4: left,  bottom, front
   vec3( 1.0f32, -1.0f32,  1.0f32),  -- 5: right, bottom, front
   vec3( 1.0f32,  1.0f32,  1.0f32),  -- 6: right, top,    front
   vec3(-1.0f32,  1.0f32,  1.0f32)]  -- 7: left,  top,    front

-- Face colors (pleasing palette - coral, teal, gold, lavender, mint, peach)
def face_colors: [6]vec3 = 
  [vec3(1.0f32,  0.5f32,  0.4f32),   -- Front:  Coral
   vec3(0.3f32,  0.7f32,  0.7f32),   -- Back:   Teal
   vec3(1.0f32,  0.8f32,  0.3f32),   -- Top:    Gold
   vec3(0.7f32,  0.6f32,  0.9f32),   -- Bottom: Lavender
   vec3(0.5f32,  0.9f32,  0.6f32),   -- Right:  Mint
   vec3(1.0f32,  0.7f32,  0.5f32)]   -- Left:   Peach

-- Background color (soft blue-gray)
def background_color: vec3 = vec3(0.4f32, 0.5f32, 0.6f32)

-- Cube face indices (6 faces × 2 triangles × 3 vertices = 36 indices)
def cube_indices: [36]i32 = 
  [-- Front face (z = 1)
   4, 5, 6,  4, 6, 7,
   -- Back face (z = -1)
   1, 0, 3,  1, 3, 2,
   -- Top face (y = 1)
   7, 6, 2,  7, 2, 3,
   -- Bottom face (y = -1)
   0, 1, 5,  0, 5, 4,
   -- Right face (x = 1)
   5, 1, 2,  5, 2, 6,
   -- Left face (x = -1)
   0, 4, 7,  0, 7, 3]

-- ============================================================================
-- Matrix Math Operations
-- ============================================================================

-- 4x4 Matrix type (row-major)
type mat4 = [4][4]f32

-- Identity matrix
def identity_mat4: mat4 = 
  [[1.0f32, 0.0f32, 0.0f32, 0.0f32],
   [0.0f32, 1.0f32, 0.0f32, 0.0f32],
   [0.0f32, 0.0f32, 1.0f32, 0.0f32],
   [0.0f32, 0.0f32, 0.0f32, 1.0f32]]

-- Matrix multiplication
def mat4_multiply (a: mat4) (b: mat4): mat4 =
  map (\row -> 
    map (\col_idx -> 
      reduce (+) 0.0f32 (map2 (*) row (map (\r -> r[col_idx]) b))
    ) (iota 4)
  ) a

-- Create rotation matrix around Y axis
def rotation_y (angle: f32): mat4 =
  let c = cos angle
  let s = sin angle
  in [[c,     0.0f32, s,     0.0f32],
      [0.0f32, 1.0f32, 0.0f32, 0.0f32],
      [-s,    0.0f32, c,     0.0f32],
      [0.0f32, 0.0f32, 0.0f32, 1.0f32]]

-- Create rotation matrix around X axis
def rotation_x (angle: f32): mat4 =
  let c = cos angle
  let s = sin angle
  in [[1.0f32, 0.0f32, 0.0f32, 0.0f32],
      [0.0f32, c,     -s,     0.0f32],
      [0.0f32, s,      c,     0.0f32],
      [0.0f32, 0.0f32, 0.0f32, 1.0f32]]

-- Create perspective projection matrix
def perspective (fov: f32) (aspect: f32) (near: f32) (far: f32): mat4 =
  let f = 1.0f32 / tan(fov * 0.5f32)
  let range_inv = 1.0f32 / (near - far)
  in [[f / aspect, 0.0f32, 0.0f32,                    0.0f32],
      [0.0f32,     f,      0.0f32,                    0.0f32],
      [0.0f32,     0.0f32, (far + near) * range_inv, -1.0f32],
      [0.0f32,     0.0f32, 2.0f32 * far * near * range_inv, 0.0f32]]

-- Transform a vec3 by a mat4 (assumes w=1)
def transform_point (m: mat4) (v: vec3): vec4 =
  let x = v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + m[0][3]
  let y = v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + m[1][3]
  let z = v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + m[2][3]
  let w = v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2] + m[3][3]
  in vec4(x, y, z, w)

-- ============================================================================
-- Shader Entry Points
-- ============================================================================

-- Uniforms (would come from uniform buffer)
#[uniform(binding = 0)]
def time: f32

#[uniform(binding = 1)]
def view_projection: mat4

-- Vertex shader
#[vertex]
def vertex_main(
  #[location(0)] vertex_id: i32,
  #[builtin(vertex_index)] gl_vertex_id: i32
): (#[builtin(position)] vec4, #[location(0)] vec3) =
  -- Calculate which vertex of which face we're rendering
  let face_id = gl_vertex_id / 6  -- Which face (0-5)
  let vertex_in_face = gl_vertex_id % 6  -- Which vertex in the face (0-5)
  
  -- Get the actual vertex index from our index buffer
  let vertex_idx = cube_indices[gl_vertex_id]
  let vertex_pos = cube_vertices[vertex_idx]
  
  -- Create model matrix with rotation
  let rotation = mat4_multiply (rotation_y (time * 0.5f32)) 
                               (rotation_x (time * 0.3f32))
  
  -- Transform vertex position
  let world_pos = transform_point rotation vertex_pos
  let clip_pos = transform_point view_projection world_pos
  
  -- Output position and color for this vertex
  let color = face_colors[face_id]
  in (clip_pos, color)

-- Fragment shader
#[fragment]
def fragment_main(
  #[location(0)] color: vec3
): #[location(0)] vec4 =
  vec4(color.x, color.y, color.z, 1.0f32)